---
title: "Data Science Capstone Report"
author: "Codrin Kruijne"
date: "10/06/2018"
output:
  html_document:
    df_print: paged
---

## Coursera Datat Science Specialization Capstone project

The goal of the capstone proejct is to create a Shiny Web app that provides predicive text suggestion for a number of typed words.

###  Technologies used

I have explored the use of the TM and TidyText packages. Hoowever, I settled on the combination below for performance and simplicity reasons. Please note the code has been written for making a language model and web app work in this education context. For more elaborate NLP it may seem succinct.

```{r message=FALSE, warning=FALSE}

require(readr) # for reading in text to build model on

require(tidyr) # for table and string manipulation
require(dplyr)
require(stringr)

require(ggplot2) # for plotting text features
require(gridExtra)

require(microbenchmark) # for comparing function performance
require(parallel) # for parallel processing

require(quanteda) # for text tokenization
quanteda_options(threads = 10) # using parallell processing; adjust for available CPU!

require(data.table) # for fast table calculation and lookup

```

## Training data

Three files were provided with a selection of tweets, news items and blog entries.

### Reading data

```{r cache=TRUE}

twitter_txt <- read_lines("en_US.twitter.txt") # read in tweets
news_txt <- read_lines("en_US.news.txt") # read in news items
blogs_txt <- read_lines("en_US.blogs.txt") # read in blog entries
 
collection_txt <- c(twitter_txt, news_txt, blogs_txt) # combine into one collection
rm(list = c("twitter_txt", "news_txt", "blogs_txt")) # remove separate source objects

print("Size of character vector with all collection elements:")
format(object.size(collection_txt), units = "auto")
print("NUmber of character elements:")
length(collection_txt)

```

### Extracting samples

Given the rather large files I will take 10 random entries from each source to explore.

```{r message=FALSE, warning=FALSE, cache=TRUE}

# Creating training set, hold out set and testing set

train_frac <- 0.8 # Percentage of training set
all_ind <- 1: length(collection_txt) # creating all indecis
train_ind <- sample(all_ind, size = train_frac * length(all_ind)) # training indeces
rest_ind <- all_ind[-train_ind] # remaining indeces to be separated
hold_ind <- sample(rest_ind, size = 0.5 * length(rest_ind)) # half hold out set
test_ind <- all_ind[-c(train_ind, hold_ind)] # hals test set

train <- collection_txt[train_ind] # create training set
hold <- collection_txt[hold_ind] # create hold out set
test <- collection_txt[test_ind] # create testing set

print(paste("Training set elements: ", length(train)))
print(paste("Hold out set elements: ", length(hold)))
print(paste("Training set elements: ", length(test)))

# Clean up
rm(collection_txt)

```

## Preprocessing: cleaning and tokenization

TODO

Removing:
- Profanity filtering
- measurements

Changing:
- word combinations to full: can't -> cannot

Stemming?

```{r cache=TRUE}

# Using Quanteda function combining preprocess operations

# firs we tokenize to sentences, so that later bigrams are not created across sentences
to_sentences <- function(sample) {
  unlist(tokens(char_tolower(sample), what = "sentence", verbose = TRUE))
}

# Extract sentences
print("Time to extract sentences out of training set:")
system.time(train_sentences <- to_sentences(train))

# A function to preprocess and tokenize to words

preprocess <- function(sample) {
  
  toks <- tokens(sample, # all lowercases
                 what = "word", # tokenize to words
                 remove_numbers = TRUE, # remove numbers
                 remove_punct = TRUE, # remove (unicode) punctuation
                 remove_symbols = TRUE, # remove (unicode) symbols
                 remove_separators = TRUE, # remove (unicode) separators 
                 remove_twitter = TRUE, # remove Twitter like @ and #
                 remove_hyphens = TRUE, # remove hyphens
                 remove_url = TRUE, # remove URLs
                 verbose = TRUE)
  
  # Additional manual preprocessing
  
  toks <- tokens_remove(toks, 
                        case_insensitive = TRUE,
                        c("(<U\\+\\w{4}>)+", # remove unicode tags
                          "RT", # remove retweet abbreviation
                          "DM", # remove direct message abbreviation
                          "\\$\\d", # remove dollar amounts
                          "[\\;\\:]\\'\\-+[\\(\\)pPD\\\\\\/\\|]", # remove smileys
                          "\\<3", # remove 'love'
                          "a\\.m\\.", # remove time abbreviations
                          "p\\.m\\.",
                          "\\d+\\:\\d+",
                          "[:digit:]{1,2}[ap]m",
                          "(.)\\1{3,}"), # remove any character that is repeated four or more times
                        valuetype = "regex",
                        verbose = TRUE)

  toks # return cleaned tokens
  
}

# Clean and tokenize training set
print("Time to preprocess training set:")
train_tokens <- preprocess(train_sentences)

# Clean up
rm(train)

```

## Ngram language modeling

We did language modeling with ngrams. Bi-/tri-/four-/fivegrams were extracted. N-gram relative frequencies were obtained by calculating the frequency of the ngram divided by the count of the base. 

```{r cache=TRUE}

# Extracting ngrams for training. This code seems somewhat unelegantly repetivite, but it allows for flexible changes and avoids memory problems related to using lists and lapply e.g. We use Quanteda functions below which can make use of 10 threads (on my mahcine!)


# Extracting bigrams

print("Time to create bigrams from training tokens")
system.time(train_bigram_dt <- data.table(ngram = unlist(tokens_ngrams(train_tokens, n = 2, concatenator = " "))))
str(train_bigram_dt)

# Extracting trigrams

print("Time to create trigrams from training tokens")
system.time(train_trigram_dt <- data.table(ngram = unlist(tokens_ngrams(train_tokens, n = 3, concatenator = " "))))
str(train_trigram_dt)

# # Extracting fourgrams
# 
# print("Time to create fourgrams from training tokens")
# system.time(train_fourgram_dt <- data.table(ngram = unlist(tokens_ngrams(train_tokens, n = 4, concatenator = " "))))
# str(train_fourgram_dt)
# 
# # Extracting fivegrams
# 
# print("Time to create fivegrams from training tokens")
# system.time(train_fivegram_dt <- data.table(ngram = unlist(tokens_ngrams(train_tokens, n = 5, concatenator = " "))))
# str(train_trigram_dt)

# Clean up
rm(train_sentences)

```

## Maximum Likelihood Estimators

```{r cache=TRUE}

# Calculating vocabulary size for smoothing

print("Time to calculate vocabulary size training set")
system.time(train_V <- length(unique(unlist(train_tokens))))
rm(train_tokens)

# For easy calculation we split the ngrams into single word columns for which we use this function

split_ngrams <- function(ngrams_dt, n){
  
  base_parts <- c("base_five",
                  "base_four",
                  "base_tri",
                  "base_bi")
  base_start <- 6 - n
  base_end <- n - 1
  ngrams_dt <- ngrams_dt %>%
                  separate(ngram,
                           into = c(base_parts[base_start:4],
                                    "prediction"),
                           sep = " ",
                           fill = "left") %>%
                  unite(1:base_end, col = "base", sep = " ")
  
}

# Splitting ngrams

print("Time of splitting training bigrams to words in columns")
system.time(train_bi_split_dt <- split_ngrams(train_bigram_dt, 2))
print("Time of splitting training trigrams to words in columns")
system.time(train_tri_split_dt <- split_ngrams(train_trigram_dt, 3))
# print("Time of splitting training fourgrams to words in columns")
# system.time(train_four_split_dt <- split_ngrams(train_fourgram_dt, 4))
# print("Time of splitting training trigrams to words in columns")
# system.time(train_five_split_dt <- split_ngrams(train_fivegram_dt, 5))

# A function for calculating Maximum Likelihood Estimations with optional add-k smoothing

mle_calculator <- function(split_ngram, smoother, voc_size) {

  k <- smoother # code was prepared for add-k smoothing
  V <- voc_size # but doing more research this does not seem to perform well
  
             # count base frequency to normalise
  dt <- split_ngram[, .(prediction, base_ct = .N), by = .(base) 
               # count ngram frequency
              ][, .(base_ct, ngram_ct = .N), by = .(base, prediction) 
                 # calculate the smoothed MLE
                ][, .(base,
                      prediction,
                      base_ct,
                      ngram_ct,
                      mle = (ngram_ct + k) / (base_ct + (k * V)))]
  
  setkey(dt)
  unique(dt)
  
}

# N model calculation

print("Time to calculate bigram MLEs with add-one smoothing")
system.time(train_bi_mle <- mle_calculator(train_bi_split_dt, 1, train_V))
print("Time to calculate trigram MLEs with add-one smoothing")
system.time(train_tri_mle <- mle_calculator(train_tri_split_dt, 1, train_V))
# print("Time to calculate fourgram MLEs with add-one smoothing")
# system.time(train_four_mle <- mle_calculator(train_four_split_dt, 1, train_V))
# print("Time to calculate fivegram MLEs with add-one smoothing")
# system.time(train_five_mle <- mle_calculator(train_five_split_dt, 1, train_V))

# Succesful MLE calculation? Clean up!
rm(train_bigram_dt)
rm(train_trigram_dt)
# rm(train_fourgram_dt)
# rm(train_fivegram_dt)

rm(train_bi_split_dt)
rm(train_tri_split_dt)
# rm(train_four_split_dt)
# rm(train_five_split_dt)

gc(verbose = TRUE)

```


## Model evaluation: Perplexity

The best evaluation method is in-vivo evaluation, but perplexity is a standard alternative applied on a separate test set.

```{r cache=TRUE}

# Perplexity is a simple way to evaluate ngram models. It is basically the product of MLEs counted on the training set, applied to the test set.

# Extract sentences

print("Time to extract sentences out of testing set:")
system.time(test_sentences <- to_sentences(test))

# Clean and tokenize datasets in same way

print("Time to preprocess testing set:")
test_tokens <- preprocess(test_sentences)
rm(test_sentences)

# Extracting bigrams

print("Time to create bigrams from testing tokens")
system.time(test_bigram_dt <- data.table(ngram = unlist(tokens_ngrams(test_tokens, n = 2, concatenator = " "))))
str(test_bigram_dt)

# Extracting trigrams

print("Time to create trigrams from testing tokens")
system.time(test_trigram_dt <- data.table(ngram = unlist(tokens_ngrams(test_tokens, n = 3, concatenator = " "))))
str(test_trigram_dt)

# # Extracting fourgrams
# 
# print("Time to create fourgrams from testing tokens")
# system.time(test_fourgram_dt <- data.table(ngram = unlist(tokens_ngrams(test_tokens, n = 4, concatenator = " "))))
# str(test_fourgram_dt)
# 
# # Extracting fivegrams
# 
# print("Time to create fivegrams from testing tokens")
# system.time(test_fivegram_dt <- data.table(ngram = unlist(tokens_ngrams(test_tokens, n = 5, concatenator = " "))))
# str(test_trigram_dt)

# Split to base and prediction

print("Time of splitting testing bigrams to words in columns")
system.time(test_bi_split_dt <- split_ngrams(test_bigram_dt, 2))

print("Time of splitting testing trigrams to words in columns")
system.time(test_tri_split_dt <- split_ngrams(test_trigram_dt, 3))
# print("Time of splitting testing bigrams to words in columns")
# system.time(test_four_split_dt <- split_ngrams(test_fourgram_dt, 4))
# print("Time of splitting testing trigrams to words in columns")
# system.time(test_five_split_dt <- split_ngrams(test_fivegram_dt, 5))

rm(test_bigram_dt)
rm(test_trigram_dt)

# A function to join training MLEs to test ngrams

model_apply <- function(test, train){
  
  # add training mles to machting testing ngrams
  dt <- data.table(left_join(test,
                             train[, c("base", "prediction", "mle")]))
  
}

# Apply models trained to test set
test_bi <- model_apply(test_bi_split_dt, train_bi_mle)

test_tri <- model_apply(test_tri_split_dt, train_tri_mle)
# test_four <- model_apply(test_four_split_dt, train_four_mle)
# test_five <- model_apply(test_five_split_dt, train_five_mle)

rm(test_bi_split_dt)
rm(test_tri_split_dt)

# Calculate Perplexity

print("Bigram model on testing set perplexity:")
test_bi_PP <- exp(-sum(log(test_bi$mle), na.rm = TRUE) / length(test_bi$mle))

rm(train_bi_mle)
rm(test_bi)

print("Trigram model on testing set perplexity:")
test_tri_PP <- exp(-sum(log(test_tri$mle), na.rm = TRUE) / length(test_tri$mle))

print("Fourgram model on testing set perplexity:")
test_four_PP <- exp(-sum(log(test_four$mle), na.rm = TRUE) / length(test_four$mle))

print("Fivegram model on testing set perplexity:")
test_five_PP <- exp(-sum(log(test_five$mle), na.rm = TRUE) / length(test_five$mle))

```


## Improving smoothing

We applied simple "add-one" or Laplace smoothing initially. Hiever, to improve smoothing, we can try to use the hold out set to improve the smoothing to add-k smoothing. K is determined by the best fit with the hold out sample.

```{r cache=TRUE}

print("Time to calculate vocabulary size hold out set")
system.time(hold_V <- length(unique(unlist(hold_tokens))))



# Calculat models on hold out sample


# Calculate best fit


# Recalculate models.


# new perplexity

```



## Creating lookup tables for App

```{r cache=TRUE}

# Now lets create a lookup table from the raw bigram probabilities

ngram_probs <- function(ngram_mle) {

  dt <- data.table::data.table(ngram_mle)
  unique(dt[, .(mle), by = .(base, prediction) # select relevant, unique rows
             ][order(base, -mle)]) # order by mle
  
}

# Basic lookup table creation SEEMS FASTER?!

system.time(bigram_lookup <- ngram_probs(bigram_mle))
system.time(trigram_lookup <- ngram_probs(trigram_mle))
# system.time(fourgram_lookup <- ngram_probs(fourgram_mle))
# system.time(fivegram_lookup <- ngram_probs(fivegram_mle))

# Lets save the lookup table as an rds file to send with Shiny App

ngram_lookup <- rbindlist(list(bigram_lookup,
                               trigram_lookup))
                               #fourgram_lookup,
                               #fivegram_lookup))

saveRDS(ngram_lookup, file = "WordPredictor/data/server_lookup.rds")

# Succesfull ngram lookup? Clean up!

rm(bigram_mle)
rm(trigram_mle)
# rm(fourgram_mle)
# rm(fivegram_mle)

rm(bigram_lookup)
rm(trigram_lookup)
# rm(fourgram_lookup)
# rm(fivegram_lookup)

```


# Testing predictions

```{r cache=TRUE}

# This code is provided for testing only. A more elaborate version will be defined in the server function of the Shiny web app.

# A lookup function: given a string, look up the most probable next word

predictWord <- function(string, ngram_lookup) {
  
  # Lookup ngram in data.table organised by ngram probability
  
  ngram_lookup[base == string][1]$prediction
  
}

```



https://youtu.be/NlmKb0X-nkA


## Ideas for improvement

- Add keys to data.tables
- Add background language model:
<https://ai.googleblog.com/2006/08/all-our-n-gram-are-belong-to-you.html>
<https://storage.googleapis.com/books/ngrams/books/datasetsv2.html>
- More sophisticated smoothing