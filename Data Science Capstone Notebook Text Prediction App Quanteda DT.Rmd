---
title: "Data Science Capstone Report"
author: "Codrin Kruijne"
date: "10/06/2018"
output:
  html_document:
    df_print: paged
---

## Coursera Data Science Specialization Capstone project

The goal of the capstone proejct is to create a Shiny Web app that provides predicive text suggestion for a number of typed words.

###  Technologies used

I have explored the use of the TM and TidyText packages. Hoowever, I settled on the combination below for performance and simplicity reasons. Please note the code has been written for making a language model and web app work in this education context. For more elaborate NLP it may seem succinct.

```{r message=FALSE, warning=FALSE}

require(readr) # for reading in text to build model on

require(tidyr) # for table and string manipulation
require(dplyr)
require(stringr)

require(ggplot2) # for plotting text features
require(gridExtra)

require(microbenchmark) # for comparing function performance
require(parallel) # for parallel processing

require(qdap) # for text preparation
require(quanteda) # for text tokenization

require(data.table) # for fast table calculation and lookup

```

## Training data

Three files were provided with a selection of tweets, news items and blog entries.

### Reading and cleaning data

```{r cache=TRUE}

twitter_txt <- read_lines("en_US.twitter.txt") # read in tweets
news_txt <- read_lines("en_US.news.txt") # read in news items
blogs_txt <- read_lines("en_US.blogs.txt") # read in blog entries

```

## Preprocessing: cleaning sources

Removing:
- Profanity filtering
- measurements

```{r cache=TRUE}

### Using QDAP functions for some initial cleaning and replacing

# A function for QDAP cleaning

clean_qdap <- function(sample_text){
  
  # Replace Abbreviations
  sample_text <- qdap::replace_ordinal(sample_text)
  
  # Replace Numbers With Text Representation
  sample_text <- qdap::replace_number(sample_text, remove = TRUE)
  
  # Replace Abbreviations
  sample_text <- qdap::replace_abbreviation(sample_text)
  
  # Replace Contractions
  sample_text <- qdap::replace_contraction(sample_text)
  
  # Replace Symbols With Word Equivalents
  sample_text <- qdap::replace_symbol(sample_text, # except for # and @
                                      pound = FALSE, # as we have twitter
                                      at = FALSE) # texts to process later
  
  # Remove dashes and brackets
  sample_text <- qdap::qprep(sample_text)
  
  sample_text # returne cleaned text
}

# Apply QDAP cleaning parallel

cl <- makeCluster(10)

print("Total time for QDAP cleaning")
system.time(clean_samples <- parLapply(cl, list(twitter_txt, news_txt, blogs_txt), clean_qdap))

stopCluster(cl)

# Extract parallel computing results

clean_twitter <- clean_samples[[1]]
clean_news <- clean_samples[[2]]
clean_blogs <- clean_samples[[3]]

saveRDS(clean_twitter, file = "clean_twitter.rds")
saveRDS(clean_news, file = "clean_news.rds")
saveRDS(clean_blogs, file = "clean_blogs.rds")

# Clean up
rm(twitter_txt)
rm(news_txt)
rm(blogs_txt)

```

### Merging source and extracting training, hold-out and testing samples

```{r message=FALSE, warning=FALSE, cache=TRUE}

# Merging into one collection

clean_twitter <- readRDS("clean_twitter.rds")
clean_news <- readRDS("clean_news.rds")
clean_blogs <- readRDS("clean_blogs.rds")

collection_txt <- c(clean_twitter, clean_news, clean_blogs) # combine into one collection
rm(list = c("clean_twitter", "clean_news", "clean_blogs")) # remove separate source objects

print("Size of character vector with all collection elements:")
format(object.size(collection_txt), units = "auto")
print("NUmber of character elements:")
length(collection_txt)

# Creating training set, hold out set and testing set

train_frac <- 0.8 # Percentage of training set
all_ind <- 1: length(collection_txt) # creating all indecis
train_ind <- sample(all_ind, size = train_frac * length(all_ind)) # training indeces
rest_ind <- all_ind[-train_ind] # remaining indeces to be separated
hold_ind <- sample(rest_ind, size = 0.5 * length(rest_ind)) # half hold out set
test_ind <- all_ind[-c(train_ind, hold_ind)] # hals test set

train <- collection_txt[train_ind] # create training set
hold <- collection_txt[hold_ind] # create hold out set
test <- collection_txt[test_ind] # create testing set

print(paste("Training set elements: ", length(train)))
print(paste("Hold out set elements: ", length(hold)))
print(paste("Training set elements: ", length(test)))

# Clean up
rm(collection_txt)
rm(train_frac)
rm(all_ind)
rm(train_ind)
rm(rest_ind)
rm(hold_ind)
rm(test_ind)

```



# Preprocessing: tokenizing

```{r cache=TRUE}

### Quanteda functions combining to tokenize and further preprocess
quanteda_options(threads = 10) # using parallell processing; adjust for available CPU!

# First, we tokenize to sentences, so that later bigrams are not created across sentences
to_sentences <- function(sample) {
  unlist(tokens(char_tolower(sample), what = "sentence", verbose = TRUE))
}

# Extract sentences
print("Time to extract sentences out of training set:")
system.time(train_sentences <- to_sentences(train))

# A function to preprocess and tokenize to words

preprocess <- function(sample) {
  
  toks <- tokens(sample, # all lowercases
                 what = "word", # tokenize to words
                 remove_numbers = TRUE, # remove numbers
                 remove_punct = TRUE, # remove (unicode) punctuation
                 remove_symbols = TRUE, # remove (unicode) symbols
                 remove_separators = TRUE, # remove (unicode) separators 
                 remove_twitter = TRUE, # remove Twitter like @ and #
                 remove_hyphens = TRUE, # remove hyphens
                 remove_url = TRUE, # remove URLs
                 verbose = TRUE)
  
  # Additional manual preprocessing
  
  toks <- tokens_remove(toks, 
                        case_insensitive = TRUE,
                        c("(<U\\+\\w{4}>)+", # remove unicode tags
                          "RT", # remove retweet abbreviation
                          "DM", # remove direct message abbreviation
                          "\\$\\d", # remove dollar amounts
                          "[\\;\\:]\\'\\-+[\\(\\)pPD\\\\\\/\\|]", # remove smileys
                          "\\<3", # remove 'love'
                          "a\\.m\\.", # remove time abbreviations
                          "p\\.m\\.",
                          "\\d+\\:\\d+",
                          "[:digit:]{1,2}[ap]m",
                          "(.)\\1{3,}"), # remove any character that is repeated four or more times
                        valuetype = "regex",
                        verbose = TRUE)

  toks # return cleaned tokens
  
}

# Clean and tokenize training set
print("Time to preprocess training set:")
train_tokens <- preprocess(train_sentences)

# Save preprocessed training data
saveRDS(train_tokens, file = "train_tokens.rds")

# Clean up
rm(train)
rm(train_sentences)
rm(train_tokens)

```

## Ngram language modeling

We did language modeling with ngrams. Bi-/tri-/four-/fivegrams were extracted. N-gram relative frequencies were obtained by calculating the frequency of the ngram divided by the count of the base. 

```{r cache=TRUE}

# Extracting ngrams for training. This code seems somewhat unelegantly repetivite, but it allows for flexible changes and avoids memory problems related to using lists and lapply e.g. We use Quanteda functions below which can make use of 10 threads (on my mahcine!)

extract_ngrams <- function(sentence_tokens, ngram_size){
  
  sentence_ngrams <- tokens_ngrams(sentence_tokens,
                                   n = ngram_size,
                                   concatenator = " ")
  
  dt <- data.table(ngram = unlist(sentence_ngrams))
  
}

# For easy calculation we split the ngrams into single word columns for which we use this function

split_ngrams <- function(ngrams_dt, n){
  
  base_parts <- c("base_five",
                  "base_four",
                  "base_tri",
                  "base_bi")
  base_start <- 6 - n
  base_end <- n - 1
  ngrams_dt <- ngrams_dt %>%
                  separate(ngram,
                           into = c(base_parts[base_start:4],
                                    "prediction"),
                           sep = " ",
                           fill = "left") %>%
                  unite(1:base_end, col = "base", sep = " ")
  
}

# A function for calculating Maximum Likelihood Estimations with optional add-k smoothing

mle_calculator <- function(split_ngram, smoother, voc_size) {

  k <- smoother * 0.7 # code was prepared for add-k smoothing
  V <- voc_size # but doing more research this does not seem to perform well
  
             # count base frequency to normalise
  dt <- split_ngram[, .(prediction, base_ct = .N), by = .(base) 
               # count ngram frequency
              ][, .(base_ct, ngram_ct = .N), by = .(base, prediction) 
                 # calculate the smoothed MLE
                ][ngram_ct > 1    # prune rarest observations
                  ][, .(base,
                        prediction,
                        base_ct,
                        ngram_ct,
                        mle = (ngram_ct + k) / (base_ct + (k * V)))]
  
  setkey(dt)
  unique(dt)
  
}

```

## Ngram model creation

```{r}

ngram_model <- function(toks, name = "bigram", size = 2, smoother = 1, voc_size){
  
  # Extracting ngrams
  
  print(paste("Time to create", name, "from tokens"))
  system.time(ngrams_dt <- extract_ngrams(toks, size))
  str(ngrams_dt)
  
  # Splitting ngrams
  
  print(paste("Time of splitting", name, "to words in columns"))
  system.time(split_dt <- split_ngrams(ngrams_dt, size))
  str(split_dt)
  rm(ngrams_dt)
  
  # MLE ngram calculation
  
  print(paste("Time to calculate", name, "MLEs with add-k smoothing"))
  system.time(ngram_mle <- mle_calculator(split_dt, smoother, voc_size))
  rm(split_dt)

  # Save to disk
  saveRDS(ngram_mle, file = paste0(name, "_mle.rds")) 
  
  # Succesful MLE calculation? Clean up!
  gc(verbose = TRUE)
  
  print(paste("Time to generate", name, "model on training set:"))
}

# Load tokens
train_tokens <- readRDS("train_tokens.rds")

# Calculating vocabulary size for smoothing
print("Time to calculate vocabulary size training set")
system.time(train_V <- length(unique(unlist(train_tokens))))

# Bigram model creation
system.time(ngram_model(train_tokens, "bigram", 2, smoother = 1, voc_size = train_V))

# Trigram model creation
system.time(ngram_model(train_tokens, "trigram", 3, smoother = 1, voc_size = train_V))

# Fourgram model creation
system.time(ngram_model(train_tokens, "fourgram", 4, smoother = 1, voc_size = train_V))

# Fivegram model creation
system.time(ngram_model(train_tokens, "fivegram", 5, smoother = 1, voc_size = train_V))

# Clean up
rm(train_tokens)
gc()

```

## Model evaluation: Perplexity

The best evaluation method is in-vivo evaluation, but perplexity is a standard alternative applied on a separate test set.

```{r cache=TRUE}

# Perplexity is a simple way to evaluate ngram models. It is basically the product of MLEs counted on the training set, applied to the test set.

# Extract sentences from test set

print("Time to extract sentences out of testing set:")
system.time(test_sentences <- to_sentences(test))

# Clean and tokenize test set in same as when modeling

print("Time to preprocess testing set:")
test_tokens <- preprocess(test_sentences)
rm(test_sentences)

# Calculating vocabulary size for perplexity calculation
print("Time to calculate vocabulary size testing set")
system.time(test_V <- length(unique(unlist(test_tokens))))

# A function to test an ngram model on testing set

test_model <- function(test_toks, name = "bigram", size = 2, voc_size){
  
  # Extract ngrams
  ngrams_dt <- extract_ngrams(test_toks, size)
  str(ngrams_dt)
  
  # Split ngrams
  split_dt <- split_ngrams(ngrams_dt, size)
  str(split_dt)
  rm(ngrams_dt)
  
  # Read in model MLE
  file_name <- paste0(name, "_mle.rds")
  print(paste("Reading file", file_name))
  model_mle <- readRDS(file_name)
  
  # Apply model test set
  dt <- data.table(left_join(split_dt,
                             model_mle[, c("base", "prediction", "mle")]))
  head(dt)
  tail(dt)
  
  # Return model perplexity
  print(paste(name, "model on testing set perplexity:"))
  print(sum(log(1/dt[, mle]), na.rm = TRUE)^1/voc_size)

}

# Test models
test_bi_PP <- test_model(test_tokens, "bigram", 2, test_V)
gc()
test_tri_PP <- test_model(test_tokens, "trigram", 3, test_V)
gc()
test_four_PP <- test_model(test_tokens, "fourgram", 4, test_V)
gc()
system.time(test_five_PP <- test_model(test_tokens, "fivegram", 5, test_V))
gc()

# Save model results
test_results <- data.frame(model = c("Bigram", "Trigram", "Fourgram", "Fivegram"), perplexity = c(test_bi_PP, test_tri_PP, test_four_PP, test_five_PP))

saveRDS(test_results, file = "WordPredictor/data/model_perplexities.rds")

```


## Improving smoothing?

We applied simple "add-one" or Laplace smoothing initially. Hiever, to improve smoothing, we can try to use the hold out set to improve the smoothing to add-k smoothing. K is determined by the best fit with the hold out sample.

```{r cache=TRUE}

# print("Time to calculate vocabulary size hold out set")
# system.time(hold_V <- length(unique(unlist(hold_tokens))))

# Calculat models on hold out sample


# Calculate best fit


# Recalculate models.


# new perplexity

```



## Creating lookup tables for App

```{r cache=TRUE}

# Now lets create a lookup table from the raw bigram probabilities

ngram_probs <- function(ngram_mle) {

  dt <- data.table::data.table(ngram_mle)
  unique(dt[, .(mle), by = .(base, prediction) # select relevant, unique rows
             ][order(base, -mle)]) # order by mle
  
}

# Basic lookup tables

system.time(bigram_lookup <- ngram_probs(readRDS("bigram_mle.rds")))
system.time(trigram_lookup <- ngram_probs(readRDS("trigram_mle.rds")))
system.time(fourgram_lookup <- ngram_probs(readRDS("fourgram_mle.rds")))
system.time(fivegram_lookup <- ngram_probs(readRDS("fivegram_mle.rds")))

# Write lookup tables to app
saveRDS(bigram_lookup, file = "WordPredictor/data/bigram_lookup.rds")
saveRDS(trigram_lookup, file = "WordPredictor/data/trigram_lookup.rds")
saveRDS(fourgram_lookup, file = "WordPredictor/data/fourgram_lookup.rds")
saveRDS(fivegram_lookup, file = "WordPredictor/data/fivegram_lookup.rds")

```


# Lookup function with 'stupid' back-off

```{r cache=TRUE}

# This code is provided for testing only to be included in the app.

# A lookup function: given a string, look up the most probable next word

predictWord <- function(string) {
  
  # QDAP clean string
    string <- scrubber(string)
    string <- qprep(string)
  
  # parse string: remove punctiation, lowercase, split into words
  words <- str_to_lower(string) %>%
             str_remove_all(pattern = "[:punct:]") %>%
             str_split(pattern = " ")
  
  # check length
  words_n <- length(words[[1]])
  
  if(words_n >= 5){ start <- words_n - 3 } else start <- 1
  
  end <- words_n
  selection <- words[[1]][start:end]
  str(selection)
  lookup_n <- length(selection)
  
  # What to look up in the lookup table
  print(paste("Lookup: ", selection))
  
  # Lookup ngram in data.table organised by ngram probability
  
  start_level <- lookup_n + 1
  print(paste("Start level:", start_level))
  
  ngram_lookup <- function(selection, level){
    
    backoff <- FALSE
    lookup <- str_c(selection, collapse = " ")
      
      if(level == 5){ # fivegram lookup
        print("Fivegram lookup!")
        
        # lookup fivegram with highest MLE
        prediction <- fivegram_lookup[base == lookup][1]$prediction
        
        if(!is.na(prediction)){ # if found
          print("FOUND FIVEGRAM!")
          print("Alternatives:")
          print(fivegram_lookup[base == lookup])
          return(prediction)
          break
        }
        else {
          print("BACKING OFF!!")
          level <- 4
          backoff <- TRUE
        }
      }
    
      if(level == 4){ # fourgram lookup
        print("Fourgram lookup!")
        
        if(backoff){
          # shorten search string
          lookup <- str_c(str_split(lookup, pattern = " ")[[1]][2:4], collapse = " ") # remove last word from search string
          last <- str_c(str_split(lookup, pattern = " ")[[1]][4], collapse = " ")
          print(paste("New lookup:", lookup))
          
          # retrieve matching fourgrams
          fourgrams <- fourgram_lookup[base == lookup]
          str(fourgrams)
          print("Old values:")
          print(fourgrams[prediction == last, .(base, prediction, mle)])
          # discount MLE of failed fivegram
          fourgrams[prediction == last, mle := 0.4 * mle] 
          print("New values:")
          print(fourgrams[prediction == last, .(base, prediction, mle)])
        }
        else {
          fourgrams <- fourgram_lookup[base == lookup]
        }

        # lookup fourgram with highest MLE
        prediction <- fourgrams[1]$prediction
        print(paste("Prediction:", prediction))
        
        if(!is.na(prediction)){
          print("FOUND FOURGRAM!")
          print("Alternatives:")
          print(fourgram_lookup[base == lookup])
          return(prediction)
          break
        }
        else {
          level <- 3
          backoff <- TRUE
        }
        
      }
    
      if(level == 3){ # trigram lookup
        print("Trigram lookup!")
        
        if(backoff){
          # shorten search string
          lookup <- str_c(str_split(lookup, pattern = " ")[[1]][2:3], collapse = " ") # remove last word from search string
          last <- str_c(str_split(lookup, pattern = " ")[[1]][3], collapse = " ")
          print(paste("New lookup:", lookup))
          
          # retrieve matching trigrams
          trigrams <- trigram_lookup[base == lookup]
          str(trigrams)
          print("Old values:")
          print(trigrams[prediction == last, .(base, prediction, mle)])
          # discount MLE of failed fourgram
          trigrams[prediction == last, mle := 0.4 * mle]
          print("New values:")
          print(trigrams[prediction == last, .(base, prediction, mle)])
        }
        else {
          trigrams <- trigram_lookup[base == lookup]
        }

        # lookup trigram with highest MLE
        prediction <- trigrams[1]$prediction
        print(paste("Prediction:", prediction))
        
        if(!is.na(prediction)){
          print("FOUND TRIGRAM!")
          print("Alternatives:")
          print(trigram_lookup[base == lookup])
          return(prediction)
          break
        }
        else {
          level <- 2
          backoff <- TRUE
        }
      }
        
      if(level == 2){ # bigram lookup
        print("Bigram lookup!")
        
        if(backoff){
          # shorten search string
          lookup <- str_c(str_split(lookup, pattern = " ")[[1]][1:1], collapse = " ") # remove last word from search string
          last <- str_c(str_split(lookup, pattern = " ")[[1]][2], collapse = " ")
          print(paste("New lookup:", lookup))
          
          # retrieve matching bigrams
          bigrams <- bigram_lookup[base == lookup]
          print("Old values:")
          print(bigrams[prediction == last, .(base, prediction, mle)])
          
          # discount MLE of failed trigram
          bigrams[prediction == last, mle := 0.4 * mle]
          print("New values:")
          print(bigrams[prediction == last, .(base, prediction, mle)])
        }
        else {
          bigrams <- bigram_lookup[base == lookup]
        }

        # lookup bigram with highest MLE
        prediction <- bigrams[1]$prediction
        print(paste("Prediction:", prediction))
        
        if(!is.na(prediction)){
          print("FOUND BIGRAM!")
          print("Alternatives:")
          print(bigram_lookup[base == lookup])
          return(prediction)
          break
        }
        else {
          print("PLEASE ENTER SOME MORE WORDS!!")
        }
      }
    
    } # end of ngram_lookup
    
    ngram_lookup(selection, start_level)
  
}

```

## Ideas for improvement

- Add keys to data.tables
- Add background language model:
<https://ai.googleblog.com/2006/08/all-our-n-gram-are-belong-to-you.html>
<https://storage.googleapis.com/books/ngrams/books/datasetsv2.html>
- More sophisticated smoothing