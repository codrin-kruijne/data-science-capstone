---
title: "Data Science Capstone Report"
author: "Codrin Kruijne"
date: "10/06/2018"
output:
  html_document:
    df_print: paged
---

## Coursera Datat Science Specialization Capstone project

The goal of the capstone proejct is to create a Shiny Web app that provides predicive text suggestion for a number of typed words.

###  Technologies used

I have explored the use of the TM and TidyText packages. Hoowever, I settled on the combination below for performance and simplicity reasons. Please note the code has been written for making a language model and web app work in this education context. For more elaborate NLP it may seem succinct.

```{r message=FALSE, warning=FALSE}

require(readr) # for reading in text to build model on

require(tidyr) # for table and string manipulation
require(dplyr)
require(stringr)

require(ggplot2) # for plotting text features
require(gridExtra)

require(microbenchmark) # for comparing function performance
require(parallel) # for parallel processing

require(quanteda) # for text tokenization
quanteda_options(threads = 10) # using parallell processing; adjust for available CPU!

require(data.table) # for fast table calculation and lookup

```

## Training data

Three files were provided with a selection of tweets, news items and blog entries.

### Reading data

```{r cache=TRUE}

twitter_txt <- read_lines("en_US.twitter.txt") # read in tweets
news_txt <- read_lines("en_US.news.txt") # read in news items
blogs_txt <- read_lines("en_US.blogs.txt") # read in blog entries
 
collection_txt <- c(twitter_txt, news_txt, blogs_txt) # combine into one collection
rm(list = c("twitter_txt", "news_txt", "blogs_txt")) # remove separate source objects

print("Size of character vector with all collection elements:")
format(object.size(collection_txt), units = "auto")
print("NUmber of character elements:")
length(collection_txt)

```

### Extracting samples

Given the rather large files I will take 10 random entries from each source to explore.

```{r message=FALSE, warning=FALSE, cache=TRUE}

# Creating training set, hold out set and testing set

train_frac <- 0.8 # Percentage of training set
all_ind <- 1: length(collection_txt) # creating all indecis
train_ind <- sample(all_ind, size = train_frac * length(all_ind)) # training indeces
rest_ind <- all_ind[-train_ind] # remaining indeces to be separated
hold_ind <- sample(rest_ind, size = 0.5 * length(rest_ind)) # half hold out set
test_ind <- all_ind[-c(train_ind, hold_ind)] # hals test set

train <- collection_txt[train_ind] # create training set
hold <- collection_txt[hold_ind] # create hold out set
test <- collection_txt[test_ind] # create testing set

print(paste("Training set elements: ", length(train)))
print(paste("Hold out set elements: ", length(hold)))
print(paste("Training set elements: ", length(test)))

# Clean up
rm(collection_txt)
rm(train_frac)
rm(all_ind)
rm(train_ind)
rm(rest_ind)
rm(hold_ind)
rm(test_ind)

```

## Preprocessing: cleaning and tokenization

TODO

Removing:
- Profanity filtering
- measurements

Changing:
- word combinations to full: can't -> cannot

Stemming?

```{r cache=TRUE}

# Using Quanteda function combining preprocess operations

# firs we tokenize to sentences, so that later bigrams are not created across sentences
to_sentences <- function(sample) {
  unlist(tokens(char_tolower(sample), what = "sentence", verbose = TRUE))
}

# Extract sentences
print("Time to extract sentences out of training set:")
system.time(train_sentences <- to_sentences(train))

# A function to preprocess and tokenize to words

preprocess <- function(sample) {
  
  toks <- tokens(sample, # all lowercases
                 what = "word", # tokenize to words
                 remove_numbers = TRUE, # remove numbers
                 remove_punct = TRUE, # remove (unicode) punctuation
                 remove_symbols = TRUE, # remove (unicode) symbols
                 remove_separators = TRUE, # remove (unicode) separators 
                 remove_twitter = TRUE, # remove Twitter like @ and #
                 remove_hyphens = TRUE, # remove hyphens
                 remove_url = TRUE, # remove URLs
                 verbose = TRUE)
  
  # Additional manual preprocessing
  
  toks <- tokens_remove(toks, 
                        case_insensitive = TRUE,
                        c("(<U\\+\\w{4}>)+", # remove unicode tags
                          "RT", # remove retweet abbreviation
                          "DM", # remove direct message abbreviation
                          "\\$\\d", # remove dollar amounts
                          "[\\;\\:]\\'\\-+[\\(\\)pPD\\\\\\/\\|]", # remove smileys
                          "\\<3", # remove 'love'
                          "a\\.m\\.", # remove time abbreviations
                          "p\\.m\\.",
                          "\\d+\\:\\d+",
                          "[:digit:]{1,2}[ap]m",
                          "(.)\\1{3,}"), # remove any character that is repeated four or more times
                        valuetype = "regex",
                        verbose = TRUE)

  toks # return cleaned tokens
  
}

# Clean and tokenize training set
print("Time to preprocess training set:")
train_tokens <- preprocess(train_sentences)

# Save preprocessed training data
saveRDS(train_tokens, file = "train_tokens.rds")

# Clean up
rm(train)
rm(train_sentences)
rm(train_tokens)

```

## Ngram language modeling

We did language modeling with ngrams. Bi-/tri-/four-/fivegrams were extracted. N-gram relative frequencies were obtained by calculating the frequency of the ngram divided by the count of the base. 

```{r cache=TRUE}

# Extracting ngrams for training. This code seems somewhat unelegantly repetivite, but it allows for flexible changes and avoids memory problems related to using lists and lapply e.g. We use Quanteda functions below which can make use of 10 threads (on my mahcine!)

extract_ngrams <- function(sentence_tokens, ngram_size){
  
  sentence_ngrams <- tokens_ngrams(sentence_tokens,
                                   n = ngram_size,
                                   concatenator = " ")
  
  dt <- data.table(ngram = unlist(sentence_ngrams))
  
}

```

## Maximum Likelihood Estimators

```{r cache=TRUE}

# For easy calculation we split the ngrams into single word columns for which we use this function

split_ngrams <- function(ngrams_dt, n){
  
  base_parts <- c("base_five",
                  "base_four",
                  "base_tri",
                  "base_bi")
  base_start <- 6 - n
  base_end <- n - 1
  ngrams_dt <- ngrams_dt %>%
                  separate(ngram,
                           into = c(base_parts[base_start:4],
                                    "prediction"),
                           sep = " ",
                           fill = "left") %>%
                  unite(1:base_end, col = "base", sep = " ")
  
}

# A function for calculating Maximum Likelihood Estimations with optional add-k smoothing

mle_calculator <- function(split_ngram, smoother, voc_size) {

  k <- smoother # code was prepared for add-k smoothing
  V <- voc_size # but doing more research this does not seem to perform well
  
             # count base frequency to normalise
  dt <- split_ngram[, .(prediction, base_ct = .N), by = .(base) 
               # count ngram frequency
              ][, .(base_ct, ngram_ct = .N), by = .(base, prediction) 
                 # calculate the smoothed MLE
                ][, .(base,
                      prediction,
                      base_ct,
                      ngram_ct,
                      mle = (ngram_ct + k) / (base_ct + (k * V)))]
  
  setkey(dt)
  unique(dt)
  
}

```

## Ngram model creation

```{r}

ngram_model <- function(toks, name = "bigram", size = 2, smoother = 1, voc_size){
  
  # Extracting ngrams
  
  print(paste("Time to create", name, "from tokens"))
  system.time(ngrams_dt <- extract_ngrams(toks, size))
  str(ngrams_dt)
  
  # Splitting ngrams
  
  print(paste("Time of splitting", name, "to words in columns"))
  system.time(split_dt <- split_ngrams(ngrams_dt, size))
  str(split_dt)
  rm(ngrams_dt)
  
  # MLE ngram calculation
  
  print(paste("Time to calculate", name, "MLEs with add-one smoothing"))
  system.time(ngram_mle <- mle_calculator(split_dt, smoother, voc_size))
  rm(split_dt)

  # Save to disk
  saveRDS(ngram_mle, file = paste0(name, "_mle.rds")) 
  
  # Succesful MLE calculation? Clean up!
  gc(verbose = TRUE)
  
  print(paste("Time to generate", name, "model on training set:"))
}

# Load tokens
train_tokens <- readRDS("train_tokens.rds")

# Calculating vocabulary size for smoothing
print("Time to calculate vocabulary size training set")
system.time(train_V <- length(unique(unlist(train_tokens))))

# Bigram model creation
system.time(ngram_model(train_tokens, "bigram", 2, smoother = 1, voc_size = train_V))

# Trigram model creation
system.time(ngram_model(train_tokens, "trigram", 3, smoother = 1, voc_size = train_V))

# Fourgram model creation
system.time(ngram_model(train_tokens, "fourgram", 4, smoother = 1, voc_size = train_V))

# Fivegram model creation
system.time(ngram_model(train_tokens, "fivegram", 5, smoother = 1, voc_size = train_V))

# Clean up
rm(train_tokens)
gc()
```

## Model evaluation: Perplexity

The best evaluation method is in-vivo evaluation, but perplexity is a standard alternative applied on a separate test set.

```{r cache=TRUE}

# Perplexity is a simple way to evaluate ngram models. It is basically the product of MLEs counted on the training set, applied to the test set.

# Extract sentences from test set

print("Time to extract sentences out of testing set:")
system.time(test_sentences <- to_sentences(test))

# Clean and tokenize test set in same as when modeling

print("Time to preprocess testing set:")
test_tokens <- preprocess(test_sentences)
rm(test_sentences)

# Calculating vocabulary size for perplexity calculation
print("Time to calculate vocabulary size testing set")
system.time(test_V <- length(unique(unlist(test_tokens))))

# A function to test an ngram model on testing set

test_model <- function(test_toks, name = "bigram", size = 2, voc_size){
  
  # Extract ngrams
  ngrams_dt <- extract_ngrams(test_toks, size)
  str(ngrams_dt)
  
  # Split ngrams
  split_dt <- split_ngrams(ngrams_dt, size)
  str(split_dt)
  rm(ngrams_dt)
  
  # Read in model MLE
  file_name <- paste0(name, "_mle.rds")
  print(paste("Reading file", file_name))
  model_mle <- readRDS(file_name)
  
  # Apply model test set
  dt <- data.table(left_join(split_dt,
                             model_mle[, c("base", "prediction", "mle")]))
  head(dt)
  tail(dt)
  
  # Return model perplexity
  print(paste(name, "model on testing set perplexity:"))
  print(sum(log(1/dt[, mle]), na.rm = TRUE)^1/voc_size)

}

# Test models
test_bi_PP <- test_model(test_tokens, "bigram", 2, test_V)
gc()
test_tri_PP <- test_model(test_tokens, "trigram", 3, test_V)
gc()
test_four_PP <- test_model(test_tokens, "fourgram", 4, test_V)
gc()
system.time(test_five_PP <- test_model(test_tokens, "fivegram", 5, test_V))
gc()

# Save model results
test_results <- list(c("bigram", "trigram", "fourgram", "fivegram"), c(test_bi_PP, test_tri_PP, test_four_PP, test_five_PP))

```


## Improving smoothing?

We applied simple "add-one" or Laplace smoothing initially. Hiever, to improve smoothing, we can try to use the hold out set to improve the smoothing to add-k smoothing. K is determined by the best fit with the hold out sample.

```{r cache=TRUE}

print("Time to calculate vocabulary size hold out set")
system.time(hold_V <- length(unique(unlist(hold_tokens))))



# Calculat models on hold out sample


# Calculate best fit


# Recalculate models.


# new perplexity

```



## Creating lookup tables for App

```{r cache=TRUE}

# Now lets create a lookup table from the raw bigram probabilities

ngram_probs <- function(ngram_mle) {

  dt <- data.table::data.table(ngram_mle)
  unique(dt[, .(mle), by = .(base, prediction) # select relevant, unique rows
             ][order(base, -mle)]) # order by mle
  
}

# Basic lookup tables

system.time(bigram_lookup <- ngram_probs(readRDS("bigram_mle.rds")))
system.time(trigram_lookup <- ngram_probs(readRDS("trigram_mle.rds")))
system.time(fourgram_lookup <- ngram_probs(readRDS("fourgram_mle.rds")))
system.time(fivegram_lookup <- ngram_probs(readRDS("fivegram_mle.rds")))

# Merge the lookup table as an rds file to send with Shiny App

# ngram_lookup <- rbindlist(list(bigram_lookup,
#                                trigram_lookup,
#                                fourgram_lookup,
#                                fivegram_lookup))
# 
# saveRDS(ngram_lookup, file = "WordPredictor/data/server_lookup.rds")

# Clean up
# rm(bigram_lookup)
# rm(trigram_lookup)
# rm(fourgram_lookup)
# rm(fivegram_lookup)

```


# Testing predictions

```{r cache=TRUE}

# This code is provided for testing only. A more elaborate version will be defined in the server function of the Shiny web app.

# A lookup function: given a string, look up the most probable next word

predictWord <- function(string) {
  
  # parse string: remove punctiation, lowercase, split into words
  words <- str_to_lower(string) %>%
             str_remove_all(pattern = "[:punct:]") %>%
             str_split(pattern = " ")
  
  # check length
  words_n <- length(words[[1]])
  
  if(words_n >= 5){ start <- words_n - 3 } else start <- 1
  
  end <- words_n
  selection <- words[[1]][start:end]
  str(selection)
  lookup_n <- length(selection)
  
  # What to look up in the lookup table
  print(paste("Lookup: ", lookup))
  
  # Lookup ngram in data.table organised by ngram probability
  
  ngram_lookup <- function(level, selection){
      lookup <- str_c(selection, collapse = " ")
      if(level = 5){ # fivegram lookup
        prediction <- fivegram_lookup[base == lookup][1]$prediction
          if(!is.na(prediction)){
            print("FOUND SOMETHING!")
            return(prediction)
            break
          }
      }
      
  }
  
  

  # fourgram lookup
  lookup <- 
  fourgram_lookup[base == lookup, mle := 0.4*mle] # apply discount
  prediction <- fourgram_lookup[base == lookup][1]$prediction
  
  if(!is.na(prediction)){
    print("FOUND SOMETHING!")
    return(prediction)
    break
  }
  # trigram lookup
  trigram_lookup[base == lookup, mle := 0.4*mle] # apply discount
  prediction <- fourgram_lookup[base == lookup][1]$prediction
  
  if(!is.na(prediction)){
    print("FOUND SOMETHING!")
    return(prediction)
    break
  }
}

```



https://youtu.be/NlmKb0X-nkA


## Ideas for improvement

- Add keys to data.tables
- Add background language model:
<https://ai.googleblog.com/2006/08/all-our-n-gram-are-belong-to-you.html>
<https://storage.googleapis.com/books/ngrams/books/datasetsv2.html>
- More sophisticated smoothing